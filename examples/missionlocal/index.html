<html>
    <head>
        <title>Mission Loc@l Crime Reports</title>
        <script type="text/javascript" src="../../lib/jquery-1.5.min.js"></script>
        <script type="text/javascript" src="../../lib/modestmaps.js"></script>
        <script type="text/javascript" src="../../lib/modestmaps.markers.js"></script>
        <script type="text/javascript" src="../../src/htmapl.js"></script>
        <script type="text/javascript" src="utils.js"></script>
        <style type="text/css">
            @import url(style.css);
        </style>
    </head>
    <body>
        <div class="map interact hash" id="sanfrancisco"
            data-base="http://acetate.geoiq.com/tiles/acetate/{Z}/{X}/{Y}.png"
            data-center="37.7602,-122.4146"
            data-zoom="14"
            data-zoomRange="12,17">
            <div id="crimes" class="layer" data-type="geoJson-p"
                data-url="http://dotpoop.appspot.com/?uid=206&amp;sid=881"></div>
            <h2><a href="http://dotspotting.org/u/206/sheets/881">Mission Crime Reports</a></h2>
        </div>
        <script type="text/javascript" defer="defer">

            // gather page parameters from the query string
            var params = {user: 206},
                paramMatch = location.search.match(/(\w+)=([^&$]+)/g);
            if (paramMatch) {
                var len = paramMatch.length;
                for (var i = 0; i < len; i++) {
                    var part = paramMatch[i].split("=");
                    params[part[0]] = part[1];
                }
            }

            // TODO: get the title from the JSON response here
            if (params.title) {
                $("h2").text(decodeURIComponent(params.title));
            } else {
                $("h2").css("display", "none");
            }

            /**
             * TODO: don't use the dotpoop proxy once Dotspotting has proper
             * JSON-P callback support.
             */
            var url = "http://dotpoop.appspot.com/";
            if (params.search) {
                params = {
                    e: params.search,
                    u: params.user,
                    s: params.sheet,
                    inline: 1,
                    force: 1 // use response caching
                };
                // TODO: update with production URL once it's live
                url = "http://dev.dotspotting.stamen.com/search/export?format=json";
            } else {
                params = {
                    uid: params.user,
                    sid: params.sheet
                };
            }
            // update the URL
            var updated = false;
            for (var p in params) {
                if (typeof params[p] !== "undefined" && String(params[p]).length > 0) {
                    url += (url.indexOf("?") > -1) ? "&" : "?";
                    url += p + "=" + params[p];
                    updated = true;
                }
            }
            if (updated) {
                $("#crimes").data("url", url);
            } else {
                // console.log("using default url:", $("#crimes").data("url"));
            }

            function getCrimeGroup(crime_type) {
                switch (crime_type) {
                    case "AGGRAVATED ASSAULT":
                    case "MURDER":
                    case "ROBBERY":
                    case "SIMPLE ASSAULT":
                        return "violent";
                    case "DISTURBING THE PEACE":
                    case "NARCOTICS":
                    case "ALCOHOL":
                    case "PROSTITUTION":
                        return "qol";
                    case "THEFT":
                    case "VEHICLE THEFT":
                    case "VANDALISM":
                    case "BURGLARY":
                    case "ARSON":
                        return "property";
                }
                return "other";
            }

            function abbreviate(group) {
                var words = group.split(" ");
                if (words.length > 1) {
                    return words[0].charAt(0) + words[1].charAt(0);
                } else {
                    return group ? group.substr(0, 2) : "Ot";
                }
            } 

            function getIcon(props) {
                return "icons/{type}.png"
                    .replace("{type}", props.crime_type.replace(/ /g, "_"));
            }

            // Do all this stuff on load
            $(function() {
                $("div.map").htmapl().each(function() {
                    var container = $(this),
                        map = container.data("map"),
                        city = container.attr("id"),
                        crimes = $("#crimes").first(),
                        layer = crimes.data("layer"),
                        markers = [];

                    /**
                     * Read the center and zoom (#zoom/lat/lon) from the
                     * fragment identifier, and keep reading it.
                     */
                    var alreadyCentered = false,
                        hash = new MapHash(map.modest);
                    if (location.hash.length > 1) {
                        alreadyCentered = hash.read(location.hash);
                    }
                    hash.start(); // udpate on pan/zoom

                    function getHref(props, id) {
                        return "http://dotspotting.org/u/{user_id}/dots/{id}/"
                            .replace("{user_id}", props.user_id)
                            .replace("{id}", id);
                    }

                    function over() {
                        var that = this,
                            type = $(this).data("crime_type");
                        $(markers).each(function() {
                            var o = $(this),
                                match = (this == that || o.data("crime_type") == type);
                            o.toggleClass("faded", !match); // .css("z-index", match ? 999 : 0);
                        });
                    }

                    function out() {
                        $(markers).removeClass("faded");
                    }

                    function updateFinally() {
                        try {
                            clusterMarkers();
                            updateExtent();
                        } catch (e) {
                            // console.warn("ERROR updateFinally():", e);
                        }
                    }

                    /**
                     * The layer template is a function that takes a GeoJSON
                     * feature and returns a DOM element marker.
                     */
                    layer.template(function(feature) {
                        try {

                            var props = feature.properties,
                                type = props["crime type"],
                                group = getCrimeGroup(type),
                                abbr = abbreviate(type),
                                desc = props["crime description"] || props["description"] || "",
                                href = getHref(props, feature.id);
                            // console.log([type, abbr, group, desc, href]);
                            var marker = $("<a/>")
                                .addClass("report")
                                .addClass(group)
                                .data("crime_type", type)
                                .data("crime_group", group)
                                .append($("<span/>")
                                    .addClass("group")
                                    .text(abbr))
                                .append($("<span/>")
                                    .addClass("desc")
                                    .text(desc)
                                    .append($("<span/>")
                                        .addClass("date")
                                        .text(" on " + props["date"] + " @ " + props["time"])));
                            if (href) {
                                marker.attr("href", href);
                            }
                            // interaction handlers
                            marker.mouseover(defer(over, 50));
                            marker.mouseout(defer(out, 50));
                            // remember it for iteration later
                            markers.push(marker[0]);

                            // defer a final update for a while so we can
                            // cluster and set the initial map extent
                            defer(updateFinally, 100)();

                            return marker[0]; // return the actual DOM node

                        } catch (e) {
                            // console.warn("ERROR (marker):", e);
                            return null;
                        }
                    });

                    // Quantize a number by a divisor
                    function quantize(n, q) {
                        return Math.round(n / q) * q;
                    }

                    /**
                     * Quantize the location of the marker to determine its "corner".
                     * Note: we should probably avoid offsetting markers with
                     * more explicit locations.
                     */
                    function getCorner(marker) {
                        var loc = marker.location,
                            prec = .001,
                            x = Number(loc.lon),
                            y = Number(loc.lat);
                        try {
                            return quantize(x, prec)+ "," + quantize(y, prec);
                        } catch (e) {
                            return "bad";
                        }
                    }

                    /**
                     * Here we group all of the markers by their "corner"
                     * (quantized location, see getCorner() above) and
                     * distribute overlapping markers in a circle around the
                     * center of the first one in the cluster.
                     */
                    function clusterMarkers() {
                        var corners = {},
                            len = markers.length;
                        for (var i = 0; i < len; i++) {
                            var marker = markers[i],
                                loc = marker.location,
                                corner = getCorner(marker);
                            if (loc.lat != 0 && loc.lon != 0) {
                                if (corner in corners) {
                                    corners[corner].push(marker);
                                } else {
                                    corners[corner] = [marker];
                                }
                            }
                        }
                        for (var corner in corners) {
                            var m = corners[corner];
                            if (m.length > 1) {
                                var r = .0000004,
                                    // TODO: use the center instead?
                                    c = m[0].coord,
                                    a = Math.PI / 40,
                                    step = Math.PI * 2 / m.length;
                                for (var i = 0; i < m.length; i++) {
                                    var offset = {
                                        row: Math.cos(a) * r,
                                        col: Math.sin(a) * r
                                    };
                                    m[i].coord.row += offset.row;
                                    m[i].coord.column += offset.col;
                                    a += step;
                                }
                            }
                        }
                        // force a redraw
                        map.zoom(map.zoom());
                    }

                    /**
                     * Here we grab all of the locations and set the map extent.
                     */
                    function updateExtent() {
                        var locations = [],
                            len = markers.length;
                        for (var i = 0; i < len; i++) {
                            var marker = markers[i],
                                loc = marker.location,
                                corner = getCorner(marker);
                            if (loc.lat != 0 && loc.lon != 0) {
                                locations.push(loc);
                            }
                        }
                        if (locations.length && !alreadyCentered) {
                            map.extent(locations);
                        }
                    }

                });
            });
        </script>

    </body>
</html>
